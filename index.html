<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <title>Water demo</title>
  <style>
    canvas {
      width: 800px;
      height: 500px
    }
  </style>

  <script src="./js/three.js"></script>
  <script src="./js/OrbitControls.js"></script>
  <script src="./js/dat.gui.js"></script>
  <script src="./js/tw.js"></script>

</head>

<body>
  <h1>Water Shader Demo</h1>
  <ul>
    <li>Space: start/stop animation
    </li>
    <li>1: take one step
    </li>
    <li>0: reset time
    </li>
  </ul>
  <script>

    const _VS =

      `

      float rand(vec2 co){
        return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
      }
      uniform float time;
      varying vec3 worldPosition;

      void main() {


        const float pi = 3.1415926535897932384626433832795;
        vec3 position = position;
        float time = time;
        float offset = rand(position.xy);

        position.z += (sin(0.25 * pi * position.x + time + offset) + sin(0.33 * pi * position.y + time + offset) + sin(0.5 * pi * position.x + time + offset) )* 0.4 + offset * 0.2;
        worldPosition = position;



        vec3 scale = vec3(1, 1, 1);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position*scale, 1.0);

      }`

    

    const _FS = 
      `
      varying vec3 worldPosition;
      uniform float time;
      uniform float red_power;
      uniform float green_power;
      uniform float blue_power;
      uniform float red_offset;
      uniform float green_offset;
      uniform float blue_offset;
      void main(){

        // scale z to be between 0 and 1
        float scaledZ = (worldPosition.z + 5.0) / 10.0;

        //set rgb to be blue at middle and white at top
        float red = red_offset - pow(scaledZ, red_power);
        float green = green_offset - pow(scaledZ, green_power);
        float blue = blue_offset - pow(scaledZ, blue_power);

        if (blue < 0.0) {
          blue = 0.0;
        }else if (blue > 1.0) {
          blue = 1.0;
        }
        if (green < 0.0) {
          green = 0.0;
        }else if (green > 1.0) {
          green = 1.0;
        }
        if (red < 0.0) {
          red = 0.0;
        }else if (red > 1.0) {
          red = 1.0;
        }


  


        gl_FragColor = vec4(red, green, blue, 1.0);

  
      }`
    

    // parameters of the scene and animation

    var guiParams = {
      time_increment: 0.1,
      red_power: 1.5,
      green_power: 2.4,
      blue_power: 0.6,
      red_offset: 0.6,
      green_offset: 0.6,
      blue_offset: 1.3

    };


    var scene = new THREE.Scene();


    var water_box_geom = new THREE.BoxGeometry(30, 30, 1, 100,100,1);

    var water_box_mat = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0.0 },
        color: { value: new THREE.Color(0x0000ff),
        },
        red_power: { value: guiParams.red_power },
        green_power: { value: guiParams.green_power },
        blue_power: { value: guiParams.blue_power},
        red_offset: { value: guiParams.red_offset },
        green_offset: { value: guiParams.green_offset },
        blue_offset: { value: guiParams.blue_offset }
      },
      vertexShader: _VS,
      fragmentShader: _FS,
      side: THREE.DoubleSide,
      wireframe: false
    });
    water_box_mat.uniforms.time.value = 0.0;


    var water_box = new THREE.Mesh(water_box_geom, water_box_mat);
    water_box.position.set(0, 0, 0);
    water_box.rotation.x = Math.PI / 2;
    scene.add(water_box);


    var renderer = new THREE.WebGLRenderer();

    TW.mainInit(renderer, scene);

    TW.cameraSetup(renderer, scene,
      {
        minx: -5, maxx: 5,
        miny: 0, maxy: 11,
        minz: -5, maxz: 5
      });

    


    function onestep(){
      water_box_mat.uniforms.time.value += guiParams.time_increment;
      TW.render()
    }

    let animation_interval = null;

    animation_interval = setInterval(onestep, 1000/60);

    document.addEventListener('keydown', function (event) {
      if (event.code == 'Space') {
        if (animation_interval) {
          clearInterval(animation_interval);
          animation_interval = null;
        } else {
          animation_interval = setInterval(onestep, 1000/60);
        }
      } else if (event.code == 'Digit0') {
        water_box_mat.uniforms.time.value = 0.0;
      } else if (event.code == 'Digit1') {
        onestep();
      }
    });

    let gui = new dat.GUI();
    gui.add(guiParams, 'time_increment', 0.0, 1.0);
    gui.add(guiParams, 'red_power', 0.0, 3.0).onChange(function(value){
      water_box_mat.uniforms.red_power.value = value;
      TW.render();
    });
    gui.add(guiParams, 'green_power', 0.0, 3.0).onChange(function(value){
      water_box_mat.uniforms.green_power.value = value;
      TW.render();
    });
    gui.add(guiParams, 'blue_power', 0.0, 3.0).onChange(function(value){
      water_box_mat.uniforms.blue_power.value = value;
      TW.render();
    });

    gui.add(guiParams, 'red_offset', 0.0, 3.0).onChange(function(value){
      water_box_mat.uniforms.red_offset.value = value;
      TW.render();
    });

    gui.add(guiParams, 'green_offset', 0.0, 3.0).onChange(function(value){
      water_box_mat.uniforms.green_offset.value = value;
      TW.render();
    });

    gui.add(guiParams, 'blue_offset', 0.0, 3).onChange(function(value){
      water_box_mat.uniforms.blue_offset.value = value;
      TW.render();
    });


    


  </script>

</body>

</html>